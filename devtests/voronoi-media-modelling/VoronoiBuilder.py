#!/usr/bin/python

import math, random, numpy, os, tempfile
from math import cos
from math import sin
from optparse import OptionParser, OptionGroup

class FileOverwriteError(Exception):
	def __init__(self, value):
		self.value = value
	def __str__(self):
		return repr(self.value)
class OptionSelectError(Exception):
	def __init__(self, value):
		self.value = value
	def __str__(self):
		return repr(self.value)

		
version = "%prog version 0.1 (04 March 2011)"
usage="""

    %prog [options]
    


    License
    -------
    (C) 2011 Stuart Curtis - sjc3g08@soton.ac.uk
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.


    Prerequisites
    -------------
    
    numpy - <http://numpy.scipy.org/> or from your distribution's repository
    Qhull - <http://qhull.org> or from your distribution's repository
    Gmesh - <http://guez.org/gmsh> or from your distribution's repository
            (used to mesh cells generated by this script)
    nmag -  <http://nmag.soton.ac.uk/nmag/> (to run the micromagnetic
            simulations)


    About
    -----

    This program creates a hexagonal lattice geometry, often found in
    perpendicular magnetic recording devices. The geometry file produced
    (FILE.geo) can be read by Gmsh and an appropriate mesh applied. The
    simulation script produced (FILE.py) is part of a script which can be read
    by nmag. It requires manual completion as the range of usage is too great to
    make it possible to automate the complete script.

    The simulation script assumes that the name of the mesh file once created by
    Gmsh and converted using nmeshimport has the same name as the .geo and .py
    files created by the script, appended with '.nmesh.h5'. If this is not the
    case, the name must be altered in the .py script manually.

    The number or rows and columns specified may be more than the number
    produced. This is especially true if a high value for standard deviation
    is used. It is therefore recommended that allow for avoiding the outer
    cells in the geometry as they will either be missing or deformed when
    choosing the number of rows and columns.

    The simulation script has the following modules imported:
    'nmag'
    'math'
    'SI' (from nmag)
    'every' (from nmag)
    'at' (from nmag)
    These are probably the most common modules imported into scripts, ('nmag' is
    mandatory and the script will not function without 'SI') any others will
    have to be added manually.

    The total size of the media must always be defined, either with the number
    of cells (using --rows and --cols) or by the dimensions in nm (--length and
    --width). Using --width and --length is an approximation as the media can
    only be defined as a whole number of grains. Usually, the total dimensions
    are slightly larger than those defined.
    
    The optional soft underlayer (SUL) has the same x and y dimensions as the 
    recording media with the z dimension and magnetic properties customisable.
    

    Limitations
    -----------

    For simplicity, this program currently uses the same standard
    deviation throughout. This includes the distance between each cell,
    grain boundary spacing (except if GB = 0)  and the rotation of the
    anisotropy axis. 
    

	
	
"""
parser = OptionParser(usage=usage,version=version)

general = OptionGroup(parser, 'General options')
media = OptionGroup(parser, 'Geometry related options')
material = OptionGroup(parser, 'Simulation script related options')
SUL = OptionGroup(parser, 'Soft underlayer (SUL) options')


general.add_option("--SD", "--standarddeviation", dest="SD",
              help="standard deviation for normally distributed dimensions. See 'Limitations' section above for more details. Default = %default", default=1.0, type="float")
general.add_option("-f", "--filename", dest="filename",
        help="name of output files (not including extension)",default="out", type="str")
general.add_option("-o", "--overwrite",
        help="choose how to handle pre-existing files; 'overwrite' automatically overwrites files with the same file name WITHOUT WARNING; 'quit' quits if file already exists; 'backup' appends.bac# to existing filename and continues with given filename. Default = %default", metavar="option", default="quit", type="str")


media.add_option("-r", "--rows", dest="rows",#default=10,
        help="number of rows (i.e. number of cells in y-direction)", type="int")
media.add_option("-c", "--cols", dest="columns",#default=10,
        help="number of columns (i.e. number of cells in x-direction)", type="int")
media.add_option("-l", "--length", dest="length",
        help="total length of media in x-dir (in nm)", type="float")
media.add_option("-w", "--width", dest="width",
        help="total width of media in y-dir (in nm)", type="float")
media.add_option("-s", "--spacing", dest="spacing",
        help="mean of normally distributed distance between centres of one cell to next (in nm)", default=10.0, type="float")
media.add_option("-t", "--thickness", dest="thickness",
        help="media thickness (in nm)", default=20.0, type="float")
media.add_option("--GB", "--grainboundaries", dest="GB",
        help="mean of normally distributed spacing between cells (in nm)", default=1.0, type="float")


material.add_option("--anisangle", dest="anisangle",
        help="mean of normally distributed rotation of anisotropy axis about x-axis. This is subsequently rotated a random amount about the z-axis to give a random anisotropy direction for each cell oriented at a mean of 3degrees from vertical. Default = %default", default=3.0, type="float")
material.add_option("--Ms", dest="Ms",
        help="saturation magnetisation (in A/m). Default = %default", default=298.0e3, type="float")
material.add_option("--exch", dest="exch",
        help="exchange coupling of the media (in J/m). Default = %default", default=1.0e-11, type="float")
material.add_option("--damping", dest="damping",
        help="damping parameter. Default = %default", default=0.02, type="float")
material.add_option("--K1", dest="K1",
        help="anisotropy constant (in J/m^3). Default = %default", default=200.0e3, type="float")

SUL.add_option("--SUL", default=False, action="store_true", help="includes a soft underlayer")
SUL.add_option("--SUL_z", dest="SUL_z", help="z-dimension of the SUL. ", type="float")
SUL.add_option("--SUL_Ms", type="float", help="Saturation magnetisation for SUL (in A/m). ", dest="SUL_Ms")
SUL.add_option("--SUL_exch",dest="SUL_exch",
        help="exchange coupling of the SUL (in J/m).", type="float")
SUL.add_option("--SUL_damping", dest="SUL_damping",
        help="SUL damping parameter.", type="float")
SUL.add_option("--SUL_gap", help="spacing between underside of media and SUL (in nm).", dest="SUL_gap", type="float" )



parser.add_option_group(general)
parser.add_option_group(media)
parser.add_option_group(material)
parser.add_option_group(SUL)

(options, args) = parser.parse_args()

#Sanity checks
if options.width == None and options.rows == None:
        raise OptionSelectError("x-dimension undefined, run again with --cols or --width defined")
elif options.length == None and options.columns == None:
        raise OptionSelectError("y-dimension undefined, run again with --rows or --length defined")
elif options.width != None and options.rows != None:
        raise OptionSelectError("x-dimension over-defined, run again with only --cols OR --width defined")
elif options.length != None and options.columns != None:
        raise OptionSelectError("y-dimension over-defined, run again with only --rows OR --length defined")

if options.SUL == False:
    if options.SUL_z != None or options.SUL_Ms != None or options.SUL_exch != None or options.SUL_damping != None or options.SUL_gap != None:
        SULSelected = str(" --SUL_z" * (options.SUL_z != None) + " --SUL_Ms" * (options.SUL_Ms != None) + " --SUL_exch" * (options.SUL_exch != None) + " --SUL_damping" * (options.SUL_damping != None) + " --SUL_gap" * (options.SUL_gap != None))
        print "You have defined options for the soft underlayer (" + SULSelected +  ") but have not specified to include one. Was this desired? (program has continued with no SUL)"
else: 
    if options.SUL_z == None or options.SUL_Ms == None or options.SUL_exch == None or options.SUL_damping == None or options.SUL_gap == None:
        SULNotSelected = str(" --SUL_z" * (options.SUL_z == None) + " --SUL_Ms" * (options.SUL_Ms == None) + " --SUL_exch" * (options.SUL_exch == None) + " --SUL_damping" * (options.SUL_damping == None) + " --SUL_gap" * (options.SUL_gap == None))
        raise OptionSelectError("WARNING: You have selected to include a soft underlayer but it is not fully defined. Please restart the simulation without --SUL or define the following options:" + SULNotSelected)



Filename = options.__dict__["filename"]
if Filename[-3:] == ".py":
	Filename = Filename[:-3]
elif Filename[-4:] == ".geo":
	Filename = Filename[:-4]

#Overwrite tests
if os.path.isfile(Filename+".py") and options.__dict__["overwrite"] != "overwrite":
	if options.__dict__["overwrite"] ==  "quit":
		raise FileOverwriteError("Nmag script '" + str(Filename) + ".py' already exists and script is set to not overwrite (--overwrite='quit' selected). Either run with --overwrite='overwrite' or --overwrite='backup' or choose another filename. (Run with --help flag for more information)")
	elif options.__dict__["overwrite"] ==  "backup":
		i = 0
		backup = Filename + ".py.bac" + str(i)
		while os.path.isfile(backup):
			i += 1
			backup = Filename + ".py.bac" + str(i)
		os.rename(Filename+".py", backup)
		print "existing file '" + Filename + ".py' backed up as '" + backup +"'"
	else:
		raise ValueError("invalid selection made. Run with --help flag for more information")

if os.path.isfile(Filename+".geo") and options.__dict__["overwrite"] != "overwrite":
	if options.__dict__["overwrite"] ==  "quit":
		raise FileOverwriteError("Geometry file '" + str(Filename) + ".geo' already exists and script is set to not overwrite (--overwrite='quit' selected). Either run with --overwrite='overwrite' or --overwrite='backup' or choose another filename. (Run with --help flag for more information)")
	elif options.__dict__["overwrite"] ==  "backup":
		i = 0
		backup = Filename + ".geo.bac" + str(i)
		while os.path.isfile(backup):
			i += 1
			backup = Filename + ".geo.bac" + str(i)
		os.rename(Filename+".geo", backup)
		print "existing file '" + Filename + ".geo' backed up as '" + backup +"'"
	else:
		raise ValueError("invalid selection made. Run with --help flag for more information")		


# import arguments
grainSize = options.__dict__["spacing"]
GB = options.__dict__["GB"]
SD = options.__dict__["SD"]
thickness = options.__dict__["thickness"]


if options.length != None:
        columns = int(math.ceil(options.__dict__["length"]/(grainSize))) + 1
else:
        columns = options.__dict__["columns"] + 1

if options.width != None:
        rows = int(math.ceil(options.__dict__["width"]/(grainSize*math.sqrt(3)/2.0))) + 2
else:
        rows = options.__dict__["rows"] + 2



##############################################################################################################################################


points = []
#Create hexagonal lattice with randomness
for i in range(rows):
	for j in range(columns):
		points.append([float(random.gauss(j*grainSize+(i%2)*grainSize/2.,SD)),float(random.gauss(i*grainSize*math.sqrt(3)/2.,SD))])
		
# turn into temporary file readable by qhull
pointsString = "2\n" + str(len(points)) + "\n"
for i in range(len(points)):
	pointsString += str(points[i][0]) + " " + str(points[i][1]) + "\n "
	
pointsFile = tempfile.NamedTemporaryFile()
pointsFile.write(pointsString)
pointsFile.seek(0)

# send file to qhull
if os.system("which qvoronoi > /dev/null") != 0:
        raise OSError("Cannot find qvoronoi, is qhull installed?")
result=os.popen("cat " + pointsFile.name +  ' | qvoronoi o')
resultText = ""
for i in result:
	resultText += i
result.close()
pointsFile.close()


resultsList = resultText.splitlines()
resultsList.pop(0)
resultsInfo = resultsList[0]
resultsList.pop(0)

# sort coordinates of points
coords = {}
for i in range(int(resultsInfo.split()[0])):
	coords[i] = (float(resultsList[i].split()[0]),float(resultsList[i].split()[1]))
	
	
# find equations of all lines
indices = resultsList[int(resultsInfo.split()[0]):]

newIndices=[]
# move points towards centre to create grain boundaries
for i in range(len(indices)):
	newIndices.append([])
	for j in range(int(indices[i].split()[0])+1):
		if j != 0:
			x_1 = coords[int(indices[i].split()[j])][0]
			y_1 = coords[int(indices[i].split()[j])][1]
			x_c = points[i][0]
			y_c = points[i][1]
			if GB == 0:
				newIndices[i].append([x_1,y_1])
			else:
				try:
					m = (y_1-y_c)/(x_1-x_c)
				except ZeroDivisionError:
					if y_1 > y_c:
						newIndices[i].append([x_1,y_1-GB])
					else:
						newIndices[i].append([x_1,y_1+GB])
					continue
				c = y_1 - m*x_1
				#print "j = ", j, "x1 = ", x_1, "y1 = ", y_1, "xc = ", x_c, "yc = ", y_c
				A = m**2 + 1
				B = 2*(c*m - y_1*m - x_1)
				C = c**2 - 2*c*y_1 + y_1**2 + x_1**2 - (abs(random.gauss(GB**2,SD)))/4.0
				#print "A = ", A, "B = ", B, "C = ", C
				try:
				    x_n1 = (-1*B + math.sqrt((B**2) - 4*A*C))/(2*A)
				    y_n1 = m*x_n1 + c
				    x_n2 = (-1*B-math.sqrt(B**2-4*A*C))/(2*A)
				    y_n2 = m*x_n2 + c
				except ValueError:
				    x_n1 = (-1*long(B) + math.sqrt((long(B)**2) - 4*long(A)*long(C)))/(2*long(A))
				    y_n1 = m*x_n1 + c
				    x_n2 = (-1*long(B)-math.sqrt(long(B)**2-4*long(A)*long(C)))/(2*long(A))
				    y_n2 = m*x_n2 + c
				#print "Xn1 = ", x_n1, "Yn1 = ", y_n1, "Xn2 = ", x_n2, "Yn2 = ", y_n2
				if math.sqrt((x_n1-x_c)**2+(y_n1-y_c)**2) < math.sqrt((x_n2-x_c)**2+(y_n2-y_c)**2):
					newIndices[i].append([x_n1,y_n1])
				else:
					newIndices[i].append([x_n2,y_n2])
					
# find lines
pointNo = 0
lines={}
lineLoops = {}
loopNo = 0
for i in newIndices:
	for j in range(len(i)):
		if j != len(i)-1:
			lines[pointNo] = (pointNo,pointNo+1)
		else:
			lines[pointNo] = (pointNo,pointNo-j)
			lineLoops[loopNo] = range(pointNo-j,pointNo+1)
			loopNo += 1
		pointNo += 1
		
		
		
# find invalid points
pointNo = 0
removedPoints = []
for i in range(len(newIndices)):
	firstPoint = pointNo
	for j in range(len(newIndices[i])):
		if newIndices[i][j][0] > columns*grainSize or newIndices[i][j][0] < 0 or newIndices[i][j][1] > rows*grainSize*math.sqrt(3)/2. or newIndices[i][j][1] < 0:
			removedPoints += (range(firstPoint,firstPoint+len(newIndices[i])))
			pointNo = firstPoint+len(newIndices[i])
			break
		pointNo += 1
		
		
		
# remove lines which go to invalid points
for i in range(len(lines)):
	if removedPoints.count(lines[i][0]) != 0 or removedPoints.count(lines[i][1]) != 0:
		del lines[i]
		
for i in lineLoops.keys():
	for j in range(len(lineLoops[i])):
		if lines.keys().count(lineLoops[i][j]) == 0:
			del lineLoops[i]
			break
			
			
			
# process information into gmsh file
plot = []
pointNo = 0
for i in range(len(newIndices)):
	for j in range(len(newIndices[i])):
		if removedPoints.count(pointNo) == 0:
			plot.append("Point("+str(pointNo)+") = {" + str(newIndices[i][j][0]) + "," + str(newIndices[i][j][1]) + "," + str(0) + "};\n")
		pointNo += 1
		
		
for i in lines.keys():
	plot.append("Line(" + str(i) + ") = {" + str(lines[i][0]) + "," + str(lines[i][1]) + "};\n")
	
surface = []
extrude = []
volumes = []
j = 1
for i in lineLoops.keys():
	plot.append("Line Loop(" + str(i) + ") = {" + str(lineLoops[i])[1:-1] + "};\n")
	surface.append("Plane Surface(" + str(max(lineLoops.keys())+i) + ") = {" + str(i)+ "};\n")
	extrude.append("Extrude {" + str(random.gauss(0,0)) +  ", " + str(random.gauss(0,0)) + ", " + str(random.gauss(-thickness,0)) + "} {\nSurface{" + str(max(lineLoops.keys())+i) + "};\n}\n")
	volumes.append("Physical Volume(" + str(j) + ") = {" + str(j) + "};\n")
	j+=1
volumeNo = j	



# find dimensions of extremities for SUL
SULgeom=[""]
if options.SUL == True:
    pointNo2=0
    xList = []
    yList = []
    for i in newIndices:
        for j in i:
            if removedPoints.count(pointNo2) == 0:
                xList.append(j[0])
                yList.append(j[1])
            pointNo2+=1
        
# Soft underlayer geometry
    SULgeom=["Point("+str(100*pointNo+1)+") = {" + str(min(xList)) + "," + str(min(yList)) + "," + str(-thickness-options.__dict__["SUL_gap"]) + "};\nPoint("+str(100*pointNo+2)+") = {" + str(min(xList)) + "," + str(max(yList)) + "," + str(-thickness-options.__dict__["SUL_gap"]) + "};\nPoint("+str(100*pointNo+3)+") = {" + str(max(xList)) + "," + str(max(yList)) + "," + str(-thickness-options.__dict__["SUL_gap"]) + "};\nPoint("+str(100*pointNo+4)+") = {" + str(max(xList)) + "," + str(min(yList)) + "," + str(-thickness-options.__dict__["SUL_gap"]) + "};\nLine(" + str(100*max(lines.keys())+1) + ") = {" + str(100*pointNo+1) + "," + str(100*pointNo+2) + "};\nLine(" + str(100*max(lines.keys())+2) + ") = {" + str(100*pointNo+2) + "," + str(100*pointNo+3) + "};\nLine(" + str(100*max(lines.keys())+3) + ") = {" + str(100*pointNo+3) + "," + str(100*pointNo+4) + "};\nLine(" + str(100*max(lines.keys())+4) + ") = {" + str(100*pointNo+4) + "," + str(100*pointNo+1) + "};\nLine Loop(" + str(100*len(lineLoops)+1) + ") = {" + str([100*max(lines.keys())+1,100*max(lines.keys())+2,100*max(lines.keys())+3,100*max(lines.keys())+4])[1:-1] + "};\nPlane Surface(" + str(100*max(lineLoops.keys())*2+1) + ") = {" + str(100*len(lineLoops)+1)+ "};\nExtrude {0,0,-" + str(options.__dict__["SUL_z"]) +"} {\nSurface{" + str(100*max(lineLoops.keys())*2+1) + "};\n}\nPhysical Volume(" + str(volumeNo) + ") = {" + str(volumeNo) + "};\n"]
	
	
plot = plot + surface + extrude + volumes + SULgeom

# write to geometry file
GmshFile = open(Filename + ".geo","w+")
for i in range(len(plot)):
	GmshFile.writelines(plot[i])
GmshFile.close()

##############################################################################################################################################

# begin simulation script

anis = []
simulation = []

for i in range(len(volumes)):

	theta = 0
	psi = random.gauss(options.__dict__["anisangle"],SD)*math.pi/180.               #rotate about x
	phi =  random.vonmisesvariate(0,0)                                              #rotate random amount about z
	
#rotation matrix
	rot = numpy.matrix(
	[[cos(phi)*cos(theta), cos(phi)*sin(theta)*sin(psi) - sin(phi)*cos(psi), cos(phi)*sin(theta)*cos(psi) + sin(phi)*sin(psi)],
	[sin(phi)*cos(theta), sin(phi)*sin(theta)*sin(phi) + cos(phi)*cos(psi), sin(phi)*sin(theta)*cos(psi)-cos(phi)*sin(psi)],
	[-1*sin(theta), cos(theta)*sin(psi), cos(theta)*cos(psi)]])
	
	anis.append((rot*numpy.matrix([[0],[0],[thickness]])).tolist())
	
# define materials for simulation script

if len(volumes) <=50:
    for i in range(len(volumes)):
	    simulation.append(["material" + str(i) + " = nmag.MagMaterial(name = 'material" + str(i) + "', Ms=SI(" + str(options.__dict__["Ms"]) + ", 'A/m'), exchange_coupling=SI(" + str(options.__dict__["exch"]) + ", 'J/m'), llg_damping=" + str(options.__dict__["damping"]) + ", anisotropy=nmag.uniaxial_anisotropy(axis=["+ str(anis[i][0][0]) +","+ str(anis[i][1][0]) + ","+ str(anis[i][2][0]) + "], K1=SI(" + str(options.__dict__["K1"]) + ", 'J/m^3')))\n\n"])

else:
    materialNo = range(1,51)*int(math.ceil(len(volumes)/50.0)) #rolling material definintion
    for i in range(1,51):
        simulation.append(["material" + str(i) + " = nmag.MagMaterial(name = 'material" + str(i) + "', Ms=SI(" + str(options.__dict__["Ms"]) + ", 'A/m'), exchange_coupling=SI(" + str(options.__dict__["exch"]) + ", 'J/m'), llg_damping=" + str(options.__dict__["damping"]) + ", anisotropy=nmag.uniaxial_anisotropy(axis=["+ str(anis[i][0][0]) +","+ str(anis[i][1][0]) + ","+ str(anis[i][2][0]) + "], K1=SI(" + str(options.__dict__["K1"]) + ", 'J/m^3')))\n\n"])
    
        
if options.SUL == True:
    simulation.append(["SUL = nmag.MagMaterial(name = 'SUL', Ms = SI(" +str(options.__dict__["SUL_Ms"]) + ",'A/m'), exchange_coupling=SI(" + str(options.__dict__["SUL_exch"]) + ", 'J/m'), llg_damping=" +str(options.__dict__["SUL_damping"]) + ")\n\n"])
	
# name and define mesh file for sim script
simulation.append(["sim = nmag.Simulation('"+str(Filename)+"')\n\n", "sim.load_mesh('"+str(Filename)+ ".nmesh.h5', ["])


# link material to mesh names
if len(volumes) <=50:
    simulation.append([])
    for i in range(len(volumes)-1):
	    simulation[-1].append("('" + str(i+1) + "', material" + str(i) + "),");
	    # add final material (to end in ')' instead of ',')
    simulation[-1].append("('" + str(len(volumes)) + "', material" + str(len(volumes)-1) + ")");
else:
    simulation.append([])
    for i in range(len(volumes)-1):
	    simulation[-1].append("('" + str(i+1) + "', material" + str(materialNo[i]) + "),");
	    # add final material (to end in ')' instead of ',')
    simulation[-1].append("('" + str(len(volumes)) + "', material" + str(materialNo[i+1]) + ")");

if options.SUL == True:
    simulation[-1].append(",('"+str(volumeNo)+"', SUL)")

# final line in simulation script
simulation.append(["], unit_length=SI(1e-9,'m'))\n\n"])

# prepend simulation script
simulation = ["import nmag, math\nfrom nmag import SI, every, at\n\n"] + simulation




# write simulation and mesh script to files
script = open(Filename+".py","w+")
for i in range(len(simulation)):
	script.writelines(simulation[i])
script.close()






